*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="propertyeditors.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS enumeratedvalueform AS form 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="lstValues" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: addvalue		&& Adds a value to the listbox
		*m: selectvalue		&& Selects the specified value
		*p: nselectedvalue		&& The item the user selected
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	AllowOutput = .F.
	AlwaysOnTop = .T.
	BorderStyle = 0
	Caption = "Form"
	DoCreate = .T.
	Height = 170
	KeyPreview = .T.
	Left = 0
	MaxButton = .F.
	MinButton = .F.
	Name = "enumeratedvalueform"
	nselectedvalue = 0		&& The item the user selected
	ShowWindow = 1
	TitleBar = 0
	Top = 0
	Width = 173
	WindowType = 1
	_memberdata = <VFPData>
		<memberdata name="addvalue" type="method" display="AddValue"/>
		<memberdata name="lvalueselected" type="property" display="lValueSelected"/>
		<memberdata name="nselectedvalue" type="property" display="nSelectedValue"/>
		<memberdata name="selectvalue" type="method" display="SelectValue"/>
		</VFPData>		&& XML Metadata for customizable properties

	ADD OBJECT 'lstValues' AS listbox WITH ;
		BoundColumn = 2, ;
		FontName = "Tahoma", ;
		FontSize = 14, ;
		Height = 170, ;
		Left = 0, ;
		Name = "lstValues", ;
		Top = 0, ;
		Width = 170
		*< END OBJECT: BaseClass="listbox" />
	
	PROCEDURE addvalue		&& Adds a value to the listbox
		lparameters tcValue, ;
			tcDescription
		with This.lstValues
			.AddListItem(tcDescription)
			.AddListItem(tcValue, .NewItemId, 2)
		endwith
		
	ENDPROC

	PROCEDURE KeyPress
		lparameters tnKeyCode, ;
			tnShiftAltCtrl
		if tnKeyCode = 27
			This.Release
		endif tnKeyCode = 27
		
	ENDPROC

	PROCEDURE selectvalue		&& Selects the specified value
		lparameters tuValue
		if vartype(tuValue) = 'N'
			This.lstValues.ListIndex = tuValue
		else
			This.lstValues.Value = tuValue
		endif vartype(tuValue) = 'N'
		
	ENDPROC

	PROCEDURE lstValues.DblClick
		Thisform.nSelectedValue = This.ListIndex
		Thisform.Hide()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS propertyeditor AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: assert		&& Determines whether the specified condition is .T. and displays a warning message if not
		*m: editproperty		&& Provides the property editor
		*m: getattributes		&& Gets attributes about the property from _MemberData
		*m: getcurrentvalue
		*m: getobjectreference		&& Gets a reference to the selected object(s)
		*m: propertyeditor		&& Implement this method in a subclass to perform the editing tasks
		*m: testcustomasserts		&& Tests any custom asserts in a subclass
		*m: updateproperty		&& Updates the property with the specified value
		*m: validateproperty		&& Ensure we have a valid property name
		*m: warning		&& Displays a warning message
		*p: ccaption		&& The name of this property editor for dialogs
		*p: cdatatype		&& The data type of the property
		*p: cproperty		&& The name of the property being edited
		*p: oattributes		&& A collection of _MemberData attributes for the property
		*p: oobjects		&& A collection of selected objects
		*p: ucurrentvalue		&& The current value for the property
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED oattributes,ucurrentvalue
	ccaption = Property Editor		&& The name of this property editor for dialogs
	cdatatype = 		&& The data type of the property
	cproperty = 		&& The name of the property being edited
	Name = "propertyeditor"
	oattributes = .NULL.		&& A collection of _MemberData attributes for the property
	oobjects = .NULL.		&& A collection of selected objects
	ucurrentvalue = .NULL.		&& The current value for the property
	Width = 17
	_memberdata = <VFPData>
		<memberdata name="assert" type="method" display="Assert"/>
		<memberdata name="ccaption" type="property" display="cCaption"/>
		<memberdata name="editproperty" type="method" display="EditProperty"/>
		<memberdata name="warning" type="method" display="Warning"/>
		<memberdata name="cproperty" type="property" display="cProperty"/>
		<memberdata name="propertyeditor" type="method" display="PropertyEditor"/>
		<memberdata name="ucurrentvalue" type="property" display="uCurrentValue"/>
		<memberdata name="testcustomasserts" type="method" display="TestCustomAsserts"/>
		<memberdata name="updateproperty" type="method" display="UpdateProperty"/>
		<memberdata name="getcurrentvalue" type="method" display="GetCurrentValue"/>
		<memberdata name="getobjectreference" type="method" display="GetObjectReference"/>
		<memberdata name="validateproperty" type="method" display="ValidateProperty"/>
		<memberdata name="getattributes" type="method" display="GetAttributes"/>
		<memberdata name="oattributes" type="property" display="oAttributes"/>
		<memberdata name="cdatatype" type="property" display="cDataType"/>
		<memberdata name="oobjects" type="property" display="oObjects"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROTECTED PROCEDURE assert		&& Determines whether the specified condition is .T. and displays a warning message if not
		lparameters tlCondition, ;
			tcMessage
		if not tlCondition
			throw tcMessage
		endif not tlCondition
		
	ENDPROC

	PROCEDURE Destroy
		* Nuke member objects.
		
		This.oObjects    = .NULL.
		This.oAttributes = .NULL.
		
	ENDPROC

	PROCEDURE editproperty		&& Provides the property editor
		local loException as Exception
		with This
			try
		
		* Get a reference to the selected objects.
		
				.oObjects = .GetObjectReference()
		
		* Ensure we have a valid property name and get its current value and any
		* attributes in _MemberData.
		
				.ValidateProperty()
				.uCurrentValue = .GetCurrentValue()
				.cDataType     = vartype(.uCurrentValue)
				.oAttributes   = .GetAttributes()
		
		* Test any other asserts, then call the "real" editor method.
		
				.TestCustomAsserts()
				.PropertyEditor()
		
		* Handle a failed assert.
		
			catch to loException when not empty(loException.UserValue)
				.Warning(loException.UserValue)
		
		* Handle any other type of error.
		
			catch to loException
				.Warning(loException.Message)
			endtry
		endwith
		
	ENDPROC

	PROTECTED PROCEDURE getattributes		&& Gets attributes about the property from _MemberData
		local loAttributes, ;
			lnSelect, ;
			loDOM as MSXML2.DOMDocument, ;
			loObject, ;
			loNode as MSXML2.IXMLDOMElement, ;
			loAttribute as MSXML2.IXMLDOMAttribute, ;
			lcName, ;
			lcValue
		loAttributes = createobject('Collection')
		lnSelect     = select()
		try
		
		* Create an XML DOM object and load the XML in the _MemberData property of the
		* first selected object. If that property doesn't exist or is empty, see if
		* there's any global Member Data for it in the IntelliSense table.
		
			loDOM = createobject('MSXML2.DOMDocument.4.0')
			loDOM.async = .F.
			loObject = This.oObjects.Item(1)
			if pemstatus(loObject, '_MemberData', 5) and ;
				not empty(loObject._MemberData)
				loDOM.loadXML(loObject._MemberData)
			else
				select 0
				use (_foxcode) again shared alias __FOXCODE
				locate for TYPE = 'E' and upper(ABBREV) = upper(This.cProperty)
				if found()
					loDOM.loadXML(TIP)
				endif found()
				use
			endif pemstatus(loObject, '_MemberData', 5) ...
		
		* Find the node for the property we're editing. If there is one, load all of
		* the attributes into the collection.
		
			loNode = loDOM.selectSingleNode('//memberdata[@name="' + ;
				lower(This.cProperty) + '"]')
			if vartype(loNode) = 'O'
				for each loAttribute in loNode.attributes
					lcName  = loAttribute.name
					lcValue = loAttribute.value
					loAttributes.Add(lcValue, lcName)
				next loAttribute
			endif vartype(loNode) = 'O'
		catch
			use in select('__FOXCODE')
		endtry
		select (lnSelect)
		return loAttributes
		
	ENDPROC

	PROTECTED PROCEDURE getcurrentvalue
		* Get the current value from the first selected object.
		
		return evaluate('This.oObjects.Item(1).' + This.cProperty)
		
	ENDPROC

	PROTECTED PROCEDURE getobjectreference		&& Gets a reference to the selected object(s)
		local laObjects[1], ;
			loObjects, ;
			lnI
		This.Assert(aselobj(laObjects) > 0 or aselobj(laObjects, 1) > 0, ;
			'No object is selected.')
		loObjects = createobject('Collection')
		for lnI = 1 to alen(laObjects)
			loObjects.Add(laObjects[lnI])
		next lnI
		return loObjects
		
	ENDPROC

	PROTECTED PROCEDURE propertyeditor		&& Implement this method in a subclass to perform the editing tasks
		* Abstract method
		
	ENDPROC

	PROTECTED PROCEDURE testcustomasserts		&& Tests any custom asserts in a subclass
		* Abstract method
		
	ENDPROC

	PROTECTED PROCEDURE updateproperty		&& Updates the property with the specified value
		lparameters tuValue
		local loObject, ;
			lcProperty
		for each loObject in This.oObjects
			lcProperty = 'loObject.' + This.cProperty
			store tuValue to (lcProperty)
		next loObject
		
	ENDPROC

	PROTECTED PROCEDURE validateproperty		&& Ensure we have a valid property name
		with This
			.Assert(vartype(.cProperty) = 'C' and not empty(.cProperty), ;
				'No property name was specified.')
			.Assert(pemstatus(.oObjects.Item(1), .cProperty, 5), ;
				.cProperty + ' is not a valid property name.')
		endwith
		
	ENDPROC

	PROTECTED PROCEDURE warning		&& Displays a warning message
		lparameters tcMessage
		messagebox(tcMessage, 48, This.cCaption)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS propertyeditorenumerated AS propertyeditor OF "propertyeditors.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: findwindow		&& Searches through child windows of the specified window to find the desired window
		*m: getwindowtitle		&& Returns the title for the specified window
	*</DefinedPropArrayMethod>

	ccaption = Enumerated Property Editor
	Name = "propertyeditorenumerated"
	_memberdata = <VFPData>
		<memberdata name="assert" type="method" display="Assert"/>
		<memberdata name="ccaption" type="property" display="cCaption"/>
		<memberdata name="editproperty" type="method" display="EditProperty"/>
		<memberdata name="warning" type="method" display="Warning"/>
		<memberdata name="cproperty" type="property" display="cProperty"/>
		<memberdata name="propertyeditor" type="method" display="PropertyEditor"/>
		<memberdata name="ucurrentvalue" type="property" display="uCurrentValue"/>
		<memberdata name="testcustomasserts" type="method" display="TestCustomAsserts"/>
		<memberdata name="updateproperty" type="method" display="UpdateProperty"/>
		<memberdata name="getcurrentvalue" type="method" display="GetCurrentValue"/>
		<memberdata name="getobjectreference" type="method" display="GetObjectReference"/>
		<memberdata name="validateproperty" type="method" display="ValidateProperty"/>
		<memberdata name="getattributes" type="method" display="GetAttributes"/>
		<memberdata name="oattributes" type="property" display="oAttributes"/>
		<memberdata name="cdatatype" type="property" display="cDataType"/>
		<memberdata name="oobjects" type="property" display="oObjects"/>
		<memberdata name="findwindow" type="method" display="FindWindow"/>
		<memberdata name="getwindowtitle" type="method" display="GetWindowTitle"/>
		</VFPData>
	
	PROTECTED PROCEDURE findwindow		&& Searches through child windows of the specified window to find the desired window
		lparameters hWnd, ;
			tcTitle
		local lcTitle, ;
			lnReturn, ;
			lnhWndChild
		lcTitle = This.GetWindowTitle(hWnd)
		if lcTitle = tcTitle
			lnReturn = hWnd
		else
			lnReturn    = 0
			lnhWndChild = 0
			do while .T.
				lnhWndChild = FindWindowEx(hWnd, lnhWndChild, 0, 0)
				if lnhWndChild = 0
					exit
				endif lnhWndChild = 0
				lnReturn = This.FindWindow(lnhWndChild, tcTitle)
				if lnReturn <> 0
					exit
				endif lnReturn <> 0
			enddo while .T.
		endif lcTitle = tcTitle
		return lnReturn
		
	ENDPROC

	PROTECTED PROCEDURE getwindowtitle		&& Returns the title for the specified window
		lparameters hWnd
		local lcTitle
		lcTitle = space(200)
		GetWindowText(hWnd, @lcTitle, len(lcTitle))
		if at(chr(0), lcTitle) > 0
			lcTitle = left(lcTItle, at(chr(0), lcTitle) - 1)
		endif at(chr(0), lcTitle) > 0
		return lcTitle
		
	ENDPROC

	PROCEDURE Init
		* Declare some Windows API functions we may need.
		
		declare integer FindWindowEx in Win32API;
			integer hWndParent, integer hWndChildAfter, string lpszClass, ;
			string lpszWindow
		declare integer GetWindowText in Win32API;
			integer hWnd, string @szText, integer nLen
		declare integer GetWindowRect in Win32API ;
			integer hWnd, string @lpRect
		
	ENDPROC

	PROCEDURE propertyeditor
		local lcValues, ;
			lcDirectory, ;
			loForm, ;
			laLines[1], ;
			lnLines, ;
			laValues[1], ;
			lnI, ;
			lcValue, ;
			lcDescription, ;
			lnTop, ;
			llDockable, ;
			lnhWnd, ;
			lcBuffer, ;
			lnWLeft, ;
			lnWRight, ;
			lnLeft
		with This
		
		* Get the editorvalues attribute.
		
			.Assert(.oAttributes.GetKey('editorvalues') > 0, ;
				'There is no editorvalues attribute in _MemberData.')
			lcValues = .oAttributes.Item('editorvalues')
		
		* Create the form to display values in and split out into the individual
		* values.
		
			lcDirectory = sys(16)
			lcDirectory = addbs(justpath(substr(lcDirectory, ;
				at(' ', lcDirectory, 2) + 1)))
			loForm      = newobject('SFEnumeratedValueForm', ;
				lcDirectory + 'SFPropertyEditor.vcx')
			lnLines     = alines(laLines, lcValues, 1, ';')
			.Assert(lnLines > 0, 'The editorvalues attribute in _MemberData does ' + ;
				'not contain a valid set of values.')
			dimension laValues[lnLines]
			for lnI = 1 to lnLines
				lcValue       = laLines[lnI]
				lcDescription = strextract(lcValue, ',')
				lcValue       = strextract(lcValue, '', ',')
				laValues[lnI] = lcValue
				loForm.AddValue(lcValue, lcValue + ' - ' + lcDescription)
			next lnI
		
		* Select the current value.
		
			loForm.SelectValue(.uCurrentValue)
		
		* Figure out where to put the form. If the Properties window is dockable
		* (whether it's currently docked or not), we have to put the form beside it
		* since we can't go on top of it. In that case, we have to use some Windows API
		* functions to locate the Properties window and determine its location. If we
		* have enough room to put the form to the right of the Properties window, do
		* so; otherwise, put it to the left.
		
			lnTop      = min(mrow('', 3), _screen.Height - loForm.Height)
			llDockable = wdockable('Properties')
			if llDockable
				lnhWnd = .FindWindow(0, 'Properties')
				if lnhWnd <> 0
					lcBuffer = replicate(chr(0), 16)
					if GetWindowRect(lnhWnd, @lcBuffer) <> 0
						lnWLeft  = ctobin(left(lcBuffer, 4), 'rs')
						lnWRight = ctobin(substr(lcBuffer, 9, 4), 'rs')
					endif GetWindowRect(lnhWnd, @lcBuffer) <> 0
					if _screen.Width - loForm.Width > lnWRight
						lnLeft = lnWRight
					else
						lnLeft = lnWLeft - loForm.Width - 5
					endif _screen.Width - loForm.Width > lnWRight
				else
					lnLeft = 0
				endif lnHWnd <> 0
			else
				lnLeft = min(mcol('', 3), _screen.Width - loForm.Width)
			endif llDockable
			loForm.Top  = lnTop
			loForm.Left = lnLeft
		
		* Display the form and get the selected value.
		
			loForm.Show()
			lcValue = laValues[loForm.nSelectedValue]
			do case
				case vartype(loForm) <> 'O' or loForm.nSelectedValue = 0
				case .cDataType = 'C'
					.UpdateProperty(lcValue)
				otherwise
					.UpdateProperty(int(val(lcValue)))
			endcase
		endwith
		
	ENDPROC

	PROCEDURE testcustomasserts
		with This
		
		* Ensure the specified property is the proper data type.
		
			.Assert(.cDataType $ 'NC', .cProperty + ' must be numeric or character.')
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS propertyeditorgetfile AS propertyeditor OF "propertyeditors.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	Name = "propertyeditorgetfile"
	
	PROCEDURE propertyeditor
		local lcExt, ;
			lcDescrip, ;
			loCommonDialog as _ComDlg of home() + 'ffc\_system.vcx', ;
			lcFile
		with This
		
		* If a fileext attribute exists, ensure a extdescrip attributes also exists and
		* that they aren't blank.
		
			if .oAttributes.GetKey('fileext') > 0
				lcExt = .oAttributes.Item('fileext')
				.Assert(.oAttributes.GetKey('extdescrip') > 0, ;
					'_MemberData must specify both fileext and extdescrip attributes.')
				lcDescrip = .oAttributes.Item('extdescrip')
				.Assert(not empty(lcExt) and not empty(lcDescrip), ;
					'The fileext and extdescrip attributes must contain values.')
				if not '.' $ lcExt
					lcExt = '*.' + lcExt
				endif not '.' $ lcExt
			else
				lcExt = ''
			endif .oAttributes.GetKey('fileext') > 0
		
		* Allow the user to select a file; we'll use the FFC _ComDlg class because it
		* gives more control than GETFILE(). If a file was selected, save it.
		
			loCommonDialog = newobject('_ComDlg', home() + 'ffc\_system.vcx')
			with loCommonDialog
				if not empty(lcExt)
					.AddFilter(lcDescrip, lcExt)
				endif not empty(lcExt)
				.cFileName         = justfname(This.uCurrentValue)
				.cInitialDirectory = addbs(justpath(This.uCurrentValue))
				.cTitleBarText     = 'Select File'
				.ShowDialog()
				lcFile = addbs(.cFilePath) + .cFileTitle
			endwith
			if not empty(lcFile)
				.UpdateProperty(lcFile)
			endif not empty(lcFile)
		endwith
		
	ENDPROC

	PROCEDURE testcustomasserts
		with This
		
		* Ensure the specified property is the proper data type.
		
			.Assert(.cDataType = 'C', .cProperty + ' must be character.')
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS propertyeditortoggle AS propertyeditor OF "propertyeditors.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	ccaption = Toggle Property Editor
	Name = "propertyeditortoggle"
	
	PROCEDURE propertyeditor
		local lnValue, ;
			lnLowValue, ;
			lcLowValueType, ;
			lnHighValue, ;
			lcHighValueType
		with This
		
		* Ensure that if either lowvalue or highvalue attributes exist that they both
		* exist and that they're reasonable values.
		
			if .oAttributes.GetKey('lowvalue') > 0
				lnValue    = .oAttributes.Item('lowvalue')
				lnLowValue = int(val(lnValue))
			endif .oAttributes.GetKey('lowvalue') > 0
			lcLowValueType = vartype(lnLowValue)
			if .oAttributes.GetKey('highvalue') > 0
				lnValue    = .oAttributes.Item('highvalue')
				lnHighValue = int(val(lnValue))
			endif .oAttributes.GetKey('highvalue') > 0
			lcHighValueType = vartype(lnHighValue)
			.Assert(lcLowValueType = lcHighValueType, ;
				'_MemberData must specify both lowvalue and highvalue attributes.')
			.Assert(lcLowValueType = 'L' or ;
				(lcLowValueType = 'N' and between(lnLowValue, 0, 10)), ;
				'The _MemberData lowvalue attribute must be 0 - 10.')
			.Assert(lcHighValueType = 'L' or ;
				(lcHighValueType = 'N' and between(lnHighValue, 0, 10)), ;
				'The _MemberData highvalue attribute must be 0 - 10.')
		
		* Toggle the property value.
		
			do case
				case .cDataType = 'L'
					.UpdateProperty(not .uCurrentValue)
				case lcHighValueType = 'N' and .uCurrentValue >= lnHighValue
					.UpdateProperty(lnLowValue)
				otherwise
					.UpdateProperty(.uCurrentValue + 1)
			endcase
		endwith
		
	ENDPROC

	PROCEDURE testcustomasserts
		with This
		
		* Ensure the specified property is the proper data type.
		
			.Assert(.cDataType $ 'NL', .cProperty + ' must be numeric or logical.')
		endwith
		
	ENDPROC

ENDDEFINE
