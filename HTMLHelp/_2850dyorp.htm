
<html>
<head>
<topictype value="TOPIC"/>
<title>SFPropertyEditorEnumerated</title>
<LINK rel="stylesheet" type="text/css" href="templates/wwhelp.css">
<SCRIPT SRC="templates/wwhelp.js"></SCRIPT>
</head>
<body leftmargin=0 topmargin=0>

<table border=0 width="100%" bgcolor="lightblue" class="banner" cellspacing="3">
<tr><td valign="center">
<span class="projectname">New Property/Method Dialog Replacement</span>
</td></tr><tr><td>
<span class="topicname">SFPropertyEditorEnumerated
</span>
</td></tr>
</table>

<div class="contentpane">
<br>Some properties contain "code" values, such as BorderStyle, in which 0 means no border, 1 means a fixed single border, 2 means a fixed dialog border, and 3 means a resizable border. Since there's a pre-defined list of values and what they mean, these are enumerated properties. You may have your own enumerated properties, such as an invoice status property that contains I for invoiced, P for posted, or V for voided. Rather than forcing the developer to remember the possible values, use SFPropertyEditorEnumerated as the editor for these properties. It displays a list of the values and their descriptions, similar to the combobox VFP displays in the Properties window for native enumerated properties.<p>SFPropertyEditorEnumerated needs a list of values to display, so the PropertyEditor method gets the value of the custom editorvalues attribute from the Member Data and parses it into separate value-description sets. PropertyEditor then instantiates SFEnumeratedValueForm, a simple form consisting of a listbox and not much code, and calls its AddValue method to add each value and description to the listbox and its SelectValue method to ensure the current value of the property is selected by default. The trickiest code involves determining where the form should go. Normally, I'd like it to be placed right at the mouse position (MROW() and MCOL() will tell us that) but if the Properties window is dockable, that won't work because the form can't be placed on top of the Properties window. So, the code uses some Windows API functions to figure out where the Properties window is located (we won't look at those methods here), decides whether to put the form to the left or right of the Properties window, and sets the form's Top and Left properties appropriately. Finally, it calls the Show method of the form, and upon return, retrieves the value the user selected from the form and updates the property depending on the data type required.<p><pre>local lcValues, ;
  lcDirectory, ;
  loForm, ;
  laLines[1], ;
  lnLines, ;
  laValues[1], ;
  lnI, ;
  lcValue, ;
  lcDescription, ;
  lnTop, ;
  llDockable, ;
  lnhWnd, ;
  lcBuffer, ;
  lnWLeft, ;
  lnWRight, ;
  lnLeft
with This

* Get the editorvalues attribute.

  .Assert(.oAttributes.GetKey('editorvalues') &gt; 0, ;
    'There is no editorvalues attribute in ' + ;
    '_MemberData.')
  lcValues = .oAttributes.Item('editorvalues')

* Create the form to display values in and split out
* into the individual values.

  lcDirectory = sys(16)
  lcDirectory = addbs(justpath(substr(lcDirectory, ;
    at(' ', lcDirectory, 2) + 1)))
  loForm      = newobject('SFEnumeratedValueForm', ;
    lcDirectory + 'SFPropertyEditor.vcx')
  lnLines     = alines(laLines, lcValues, 1, ';')
  .Assert(lnLines &gt; 0, 'The editorvalues ' + ;
    'attribute in _MemberData does not contain a ' + ;
    ' valid set of values.')
  dimension laValues[lnLines]
  for lnI = 1 to lnLines
    lcValue       = laLines[lnI]
    lcDescription = strextract(lcValue, ',')
    lcValue       = strextract(lcValue, '', ',')
    laValues[lnI] = lcValue
    loForm.AddValue(lcValue, lcValue + ' - ' + ;
      lcDescription)
  next lnI

* Select the current value.

  loForm.SelectValue(.uCurrentValue)

* Figure out where to put the form. If the Properties
* window is dockable (whether it's currently docked
* or not), we have to put the form beside it since we
* can't go on top of it. In that case, we have to use
* some Windows API functions to locate the Properties
* window and determine its location. If we have
* enough room to put the form to the right of the
* Properties window, do so; otherwise, put it to the
* left.

  lnTop      = min(mrow('', 3), _screen.Height - ;
    loForm.Height)
  llDockable = wdockable('Properties')
  if llDockable
    lnhWnd = .FindWindow(0, 'Properties')
    if lnhWnd &lt;&gt; 0
      lcBuffer = replicate(chr(0), 16)
      if GetWindowRect(lnhWnd, @lcBuffer) &lt;&gt; 0
        lnWLeft  = ctobin(left(lcBuffer, 4), 'rs')
        lnWRight = ctobin(substr(lcBuffer, 9, 4), 'rs')
      endif GetWindowRect(lnhWnd, @lcBuffer) &lt;&gt; 0
      if _screen.Width - loForm.Width &gt; lnWRight
        lnLeft = lnWRight
      else
        lnLeft = lnWLeft - loForm.Width - 5
      endif _screen.Width - loForm.Width &gt; lnWRight
    else
      lnLeft = 0
    endif lnHWnd &lt;&gt; 0
  else
    lnLeft = min(mcol('', 3), _screen.Width - ;
      loForm.Width)
  endif llDockable
  loForm.Top  = lnTop
  loForm.Left = lnLeft

* Display the form and get the selected value.

  loForm.Show()
  lcValue = laValues[loForm.nSelectedValue]
  do case
    case vartype(loForm) &lt;&gt; 'O' or ;
      loForm.nSelectedValue = 0
    case .cDataType = 'C'
      .UpdateProperty(lcValue)
    otherwise
      .UpdateProperty(int(val(lcValue)))
  endcase
endwith</pre><p>To see this editor in action, open the Test class in Test.VCX and double-click the nConnection or cStatus properties. The Member Data for both properties specifies Enumerated as the editor name passed to PropertyEditor.PRG, and Enumerated is registered in PropertyEditors.DBF as the SFPropertyEditorEnumerated class. Both of these properties have an editorvalues attribute that specifies the value and description pairs.
<br>

<p>
</div>
<hr>
<small>Last Updated: <i>11/12/2007</i></small>
</body>
</html>